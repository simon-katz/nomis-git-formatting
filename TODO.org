* nomis-git-formatting
** Done
*** DONE Have a separate `format-unpushed-commits` script
**** Useful to have as a separate thing
***** But on push will still have to check all the commits
*** DONE Bug: Uncommited changes are not restored properly
**** Some staged changes become unstaged, or is it vice versa?
*** DONE At start, print the current sha and the stash name
** To do
*** Documentation
**** TODO Create a README
**** TODO Design notes
***** Possible assumption: Files can be formatted individually
****** (if you format individual files)
**** TODO Process these notes into documentation
;;;; DONE What happens when we need to force-push?
;;;;      The sequence of commits we get will be empty.

;;;; TODO Test with a force-push.

;;;; DONE What about command-line args?
;;;;      - Grrr! Would be so much better if you could use pre and post hooks.
;;;;      - Ah, here's an idea:
;;;         - But I don't think it worls, because there will be error exits
;;;;        - Do `git push`
;;;;          - So you have all the args that `git push` has
;;;;        - The pre-push hooks calls this script and passes in the parameters.
;;;;          - This script either
;;;;            - does no-hooks when calling git push
;;;;            - creates a special file fir the pre-push hook to see
;;;;        - This script exits
;;;;          - Maybe an error exit
;;;;            - but with a message to the user saying all OK
;;;;          - Maybe a 0 exit
;;;;            - But then it will try to push again I guess
;;;;              - What will be the result of that? An error?
;;;;          - And an error exit will confuse callers, so not good
;;;;        - Another idea:
;;;;          - In this script
;;;;            - Create a special file
;;;;            - Call `git push` with all of this script's args
;;;;          - In pre-push hook
;;;;            - Check for the special file
;;;;            - Get the parameters and store them in a special file
;;;;            - exit 1 so that the push doesn't happen
;;;;          - In this script
;;;;            - Grab the stored parameters
;;;;            - So now you have the list of commits you need
;;;;            - After rewriting commits, call git push again
;;;;          - Q.
;;;;            - Think about all the possible args to git push.
;;;;              - You're not going to understand everything.
;;;;              - Maybe only allow a limited set of args
*** To check
**** TODO Maybe don't format all files
***** Can you format only some?
****** Ah!
******* You'd have to keep a cumulative collection of reformatted files
******** As you go through the series of commits
******* So move this to enhancements
******* You could copy the reformatted files to a special place
******** to save on unnecessarily repeatedly reformatting the same file
****** Old notes
******* Here's the code
******** See old repo, commit fa69126
(defn clojure-ish-file? [s]
  (or (str/ends-with? s ".clj")
      (str/ends-with? s ".cljs")
      (str/ends-with? s ".cljx")
      (str/ends-with? s ".cljc")))

  (let [changed-files (->> (git/changed-files (str user-commit-sha "~2")
                                              user-commit-sha)
                           (filter clojure-ish-file?)
                           (str/join " "))]
    (println "The changed Clojure files are:" changed-files)
    (u/bash "lein cljfmt fix" changed-files))
******* Didn't you see something not working when you used to do this?
******** Maybe it's only possible in certain circumstances
********* Oh, I guess the first commit that applies cljfmt formatting needs to do all files
********** So you need to format all files only for the first commit that you process in each run
******** Maybe grab the code from the old repo and try again
******* Is there a possibility here of exceeding the maximum shell command length?
******** But maybe it's faster, so maybe you want it
******** If you do it
********* Detect and maybe report any such error (or just any error)
********** Do it again but without passing individual files to cljfmt
******** Ah -- perhaps you can work out what the command line length would be
********* and compare it with the max allowed
********* Nope -- doesn't work because env vars are part of ARG_MAX
**** TODO Passing args
***** TODO Are you passing on command line args correctly?
****** (Shells can be weird if you aren't careful)
***** TODO Does it work with a force-push argument?
***** TODO What args does `git push` take -- you need to understand
***** TODO Are you making any unwarranted assumptions?
****** eg When you process the commits that are being pushed
******* You assume that you are on the branch concerned, right?
******** Because of the way you create commits
*** Fixes
*** Tidying
**** TODO Think about possible problems with things going wrong
***** eg special files being left around
****** Ah, you have try/catch for these I think
******* Oh, but still you could have a fatal error and exit
**** TODO Don't have the file ".git/_nomis-git-formatting--doing-wrapped-push"
***** Instead, push without running hooks
**** TODO Restoring local state if things go wrong
***** Maybe put the commands in a file
***** Be careful with the stash stuff
****** The stash might not exist when the user does this stuff
****** Can you restore a stash by name?
******* Or find a stash by name and then apply it?
**** TODO Maybe you can create a commit on a new branch, rather than stashing
***** Actually, maybe simpler of you can find a stash by name
***** But with this idea:
****** So you will always have a commit
******* Avoids problem with maybe not having a stash
******* Avoids problem with stash list maybe changing
****** So you'd reset soft to the commit, I guess
****** But what about distinguishing between stashed and unstashed
******* Ah -- maybe could do this with two commits
****** But then there is housekeeping to do -- tidy these branches
**** TODO You want to rewrite without changing the commit hashes
***** I think I saw something that lets you update objects in git
***** Oh, that's not what you had thought
****** https://stackoverflow.com/questions/31057527/git-pre-commit-hook-to-format-and-re-add-files-at-the-same-time/49265008#49265008
******* you can:
******** get the file from index as a tmp
******** format the tmp
******** replace the entry in index
***** Is it OK to replace commits at push time (as you are doing)?
***** So maybe you have to reformat on commit
****** You have both pre-commit and post-commit hooks
******* so less jiggery-pokery than you have now
**** TODO Have a single command with sub-commands
***** eg
****** nomis-git-cljfmt reformat-local
****** nomis-git-cljfmt reformat-and-push
***** or if you parameterise the formatter
****** eg
******* nomis-git-format reformat-local
******* nomis-git-format reformat-and-push
**** TODO Tidy utils and git code
***** eg The `bash` command and processing of stdout and stderr
****** Maybe just some renaming to make things clearer
*** Enhancements
**** TODO Perhaps a post-checkout hook
***** Not to format, but to create a _nomis-LOCAL-FORMATTING-NEEDED file
****** Optionally; controlled by an env var
**** TODO Parameterise the formatter
***** Maybe
****** would need to parameterise these as well:
******* whether individual files can be passed to the formatter
******* file types
***** As is done at https://stackoverflow.com/questions/31057527/git-pre-commit-hook-to-format-and-re-add-files-at-the-same-time/49265008#49265008
***** Use env vars to control things
**** TODO You can keep the old commits when there are no formatting changes
***** But one commit in a chain having a change will lead to all having a change
**** TODO You could cache info about SHAs
***** In a special file
***** eg
****** that a commit has cljfmt formatting
******* useful when doing a push after having done a `git-local-format`
****** a mapping from commits to cljfmt-ed commits
